###################################################
# 15-323 Spring 14
# Rishabh Alaap Singh (rasingh)
#
# midiControl.srp
#
# Functions that control MIDI. This file maintains
# all the scheduler code and plays all sounds. 
###################################################
require "debug"
debug_stack_print = t
require "sched"
require "midi-io"

PLAY = 0
wait_period = 0.5 # Default starting
MULTIBOARD_MAX_COL = 16 # Note there is another macro with the same name; 
# this exists here because of the dependency issues, so if changing this value
# change it in handlers.srp as well.

GAIN = 0 # Records offset from velocity array and is changed by the gain controller
# on tab 3

def activity(sequence, id, p)
    display "activity", id, the_sched.time, time_get(), p, p % MULTIBOARD_MAX_COL

    s = sequence
    c = (p % MULTIBOARD_MAX_COL)

    print INSTRUMENT_SET
    print s

    # Stop the sounds from the prev iteration
    play_sounds(s, p % MULTIBOARD_MAX_COL, 0)

    # stop AFTER note_off
    if id != PLAY 
       return

    # Play the sounds for this iteration of activity
    play_sounds(s, c, 1)

    # Increment p and analyse the new value to change the rudiment if 
    # necessary
    p = p + 1
    
    # After increment, if p mod 4 = 0 then that means we're done with 
    # this rudiment
    the_sched.cause(1, nil, 'activity', sequence, id, p)


# Physically plays the sounds using midi-io
def play_sounds(s, c, on)
    rows = len(s)
    instruments = len(INSTRUMENT_SET)

    if rows != instruments
        print "\n\nSYSTEM ERROR: THERE ARE NOT AS MANY INSTRUMENTS AS ROWS\n\n"
        return

    # Iterate through the rows of the 2D array 's' for the col 'c' specified
    # and play all notes that are a '1'
    for r = 0 to rows:
        if s[r][c] == 1:
            if on == 1:
                midi_out.note_on(0x99,INSTRUMENT_SET[r],velCap(MULTIFADER_BOARD[c] + GAIN)) 
            else:
                midi_out.note_on(0x99, INSTRUMENT_SET[r], 0)

# Changes the waiting period of the drums
def changeTempo(tempo)
    vtsched.start_use()
    vtsched.set_period(tempoToPeriod(tempo))
    vtsched.finish_use()
    display "SYSTEM: Tempo Changed to ", tempo

def togglePlay(board, instruments)
    if PLAY == 0
        PLAY = 1
        print "===============PLAYING==============="
        start_drums(wait_period)
    else
        PLAY = 0
        print "===============STOPPED==============="

# Change all the instruments by changing their channel by this much
def modInstuments(delta,up)
    var instr_len = len(INSTRUMENT_SET)
    if up == 1
        for i = 0 to instr_len
            INSTRUMENT_SET[i] = INSTRUMENT_SET[i] + delta
    else
        for i = 0 to instr_len
            INSTRUMENT_SET[i] = INSTRUMENT_SET[i] - delta
    display "SYSTEM: Instruments Modded, changed by", delta
    print INSTRUMENT_SET

def modGain(delta)
    GAIN = delta


def timer_callback()
    rtsched.poll(time_get())
    osc_server_poll()

def start_drums(wait_period)
    vtsched.start_use()
    vtsched.cause(1,nil,'activity', MULTITOGGLE_BOARD, PLAY, 0)
    the_sched.finish_use()

def setup_scheduler()
    sched_init()
    midi_out.start(0)
    rtsched.time_offset = time_get()
    vtsched.set_period(wait_period) 
    wxs_timer_start(2, 'timer_callback')
    display "SYSTEM: Scheduler has been set up"
